use crate::SwiftField;
use serde::{Deserialize, Serialize};
use std::fmt;

/// # Field 12: Message Requested
///
/// Used in MT920 (Request Message) to specify which type of statement message is being requested.
///
/// ## Format
/// `3!n` (exactly 3 numeric digits)
///
/// ## Valid Values
/// - `940`: Customer Statement Message
/// - `941`: Balance Report  
/// - `942`: Interim Transaction Report
/// - `950`: Customer Statement Message (consolidated)
///
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, SwiftField)]
#[format("3!n")]
#[validation_rules(message_type_valid = true)]
#[business_logic(message_analysis = true)]
pub struct Field12 {
    #[component("3!n", validate = "message_type")]
    pub message_type: String,
}

impl Field12 {
    /// Creates a new Field12 with validation
    ///
    /// # Arguments
    /// * `message_type` - The message type to request (must be 940, 941, 942, or 950)
    ///
    /// # Returns
    /// * `Ok(Field12)` if the message type is valid
    /// * `Err(String)` if validation fails
    ///
    /// # Examples
    /// ```rust
    /// # use swift_mt_message::fields::Field12;
    /// let field = Field12::new("940").unwrap();
    /// assert_eq!(field.message_type, "940");
    ///
    /// let invalid = Field12::new("999");
    /// assert!(invalid.is_err());
    /// ```
    pub fn new(message_type: &str) -> Result<Self, crate::ParseError> {
        let normalized = message_type.trim();

        // Validate format: exactly 3 digits
        if normalized.len() != 3 {
            return Err(crate::ParseError::InvalidFieldFormat {
                field_tag: "12".to_string(),
                message: "Message type must be exactly 3 digits".to_string(),
            });
        }

        if !normalized.chars().all(|c| c.is_ascii_digit()) {
            return Err(crate::ParseError::InvalidFieldFormat {
                field_tag: "12".to_string(),
                message: "Message type must contain only digits".to_string(),
            });
        }

        // Validate allowed values
        match normalized {
            "940" | "941" | "942" | "950" => Ok(Field12 {
                message_type: normalized.to_string(),
            }),
            _ => Err(crate::ParseError::InvalidFieldFormat {
                field_tag: "12".to_string(),
                message: format!(
                    "Invalid message type '{}'. Must be 940, 941, 942, or 950",
                    normalized
                ),
            }),
        }
    }

    // All parsing, serialization and business logic methods are auto-generated by the macro

    /// Validates the field according to SWIFT standards
    ///
    /// # Returns
    /// `true` if the field is valid, `false` otherwise
    pub fn is_valid(&self) -> bool {
        matches!(self.message_type.as_str(), "940" | "941" | "942" | "950")
            && self.message_type.len() == 3
            && self.message_type.chars().all(|c| c.is_ascii_digit())
    }

    /// Get a human-readable description of the message type
    ///
    /// # Returns
    /// A descriptive string explaining the message type
    pub fn get_description(&self) -> &'static str {
        match self.message_type.as_str() {
            "940" => "Customer Statement Message",
            "941" => "Balance Report",
            "942" => "Interim Transaction Report",
            "950" => "Customer Statement Message (Consolidated)",
            _ => "Unknown Message Type",
        }
    }

    /// Check if this is a customer statement request (940 or 950)
    ///
    /// # Returns
    /// `true` if the message type is 940 or 950
    pub fn is_customer_statement_request(&self) -> bool {
        matches!(self.message_type.as_str(), "940" | "950")
    }

    /// Check if this is a balance report request (941)
    ///
    /// # Returns
    /// `true` if the message type is 941
    pub fn is_balance_report_request(&self) -> bool {
        self.message_type == "941"
    }

    /// Check if this is an interim report request (942)
    ///
    /// # Returns
    /// `true` if the message type is 942
    pub fn is_interim_report_request(&self) -> bool {
        self.message_type == "942"
    }
}

// SwiftField implementation is auto-generated by the macro

impl fmt::Display for Field12 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Field12: {} ({})",
            self.message_type,
            self.get_description()
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_field12_creation_valid() {
        let valid_types = ["940", "941", "942", "950"];

        for msg_type in &valid_types {
            let field = Field12::new(msg_type).unwrap();
            assert_eq!(field.message_type, *msg_type);
            assert!(field.is_valid());
        }
    }

    #[test]
    fn test_field12_creation_invalid() {
        let invalid_types = ["939", "943", "999", "12", "1234", "abc", ""];

        for msg_type in &invalid_types {
            let result = Field12::new(msg_type);
            assert!(result.is_err(), "Should fail for: {}", msg_type);
        }
    }

    #[test]
    fn test_field12_parse() {
        let field = Field12::parse("942").unwrap();
        assert_eq!(field.message_type, "942");

        let field = Field12::parse(":12:941").unwrap();
        assert_eq!(field.message_type, "941");

        let field = Field12::parse("12:950").unwrap();
        assert_eq!(field.message_type, "950");
    }

    #[test]
    fn test_field12_to_swift_string() {
        let field = Field12::new("940").unwrap();
        assert_eq!(field.to_swift_string(), ":12:940");
    }

    #[test]
    fn test_field12_format_spec() {
        assert_eq!(Field12::format_spec(), "3!n");
    }

    #[test]
    fn test_field12_type_checks() {
        let stmt940 = Field12::new("940").unwrap();
        assert!(stmt940.is_customer_statement_request());
        assert!(!stmt940.is_balance_report_request());
        assert!(!stmt940.is_interim_report_request());

        let stmt950 = Field12::new("950").unwrap();
        assert!(stmt950.is_customer_statement_request());

        let balance = Field12::new("941").unwrap();
        assert!(balance.is_balance_report_request());
        assert!(!balance.is_customer_statement_request());

        let interim = Field12::new("942").unwrap();
        assert!(interim.is_interim_report_request());
        assert!(!interim.is_customer_statement_request());
    }

    #[test]
    fn test_field12_descriptions() {
        let field940 = Field12::new("940").unwrap();
        assert_eq!(field940.get_description(), "Customer Statement Message");

        let field941 = Field12::new("941").unwrap();
        assert_eq!(field941.get_description(), "Balance Report");

        let field942 = Field12::new("942").unwrap();
        assert_eq!(field942.get_description(), "Interim Transaction Report");

        let field950 = Field12::new("950").unwrap();
        assert_eq!(
            field950.get_description(),
            "Customer Statement Message (Consolidated)"
        );
    }

    #[test]
    fn test_field12_display() {
        let field = Field12::new("942").unwrap();
        let display = format!("{}", field);
        assert!(display.contains("942"));
        assert!(display.contains("Interim Transaction Report"));
    }

    #[test]
    fn test_field12_serialization() {
        let field = Field12::new("941").unwrap();
        let serialized = serde_json::to_string(&field).unwrap();
        let deserialized: Field12 = serde_json::from_str(&serialized).unwrap();
        assert_eq!(field, deserialized);
    }
}
