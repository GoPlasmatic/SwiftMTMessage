# Parser Module Architecture

This module contains the SWIFT MT message parsing implementation. The architecture follows a hybrid approach where core parsing logic is kept in the main library while field and message-level parsing is generated by macros.

## Module Structure

- **mod.rs**: Module exports and public API
- **parser_impl.rs**: Core parser implementation including SwiftParser, block extraction, and message type detection
- **sequence_parser.rs**: Sequence parsing logic for messages with multiple sequences (MT101, MT104, etc.)
- **generated.rs**: Parser functions that were extracted from parser_impl.rs for better separation
- **generated_sequences.rs**: Sequence parsing functions extracted for consistency

## Architecture Decisions

### What's Generated by Macros
- Field-level parsing (via `#[derive(SwiftField)]`)
- Message-level parsing (via `#[derive(SwiftMessage)]`)
- Field format validation and conversion
- Sample data generation

### What Remains in Main Library
- **Header Parsing**: Block 1, 2, 3, and 5 parsing remains in the main library as these are foundational components
- **Block Extraction**: The logic to extract blocks from raw SWIFT messages
- **Field Normalization**: Tag normalization and variant handling
- **Sequence Parsing**: Complex sequence splitting and boundaries detection

### Rationale

The current architecture balances several concerns:

1. **Practicality**: Header parsing is foundational and rarely changes, so keeping it in the main library avoids unnecessary complexity

2. **Performance**: Core parsing functions benefit from being compiled directly rather than generated

3. **Maintainability**: The macro system generates repetitive field/message parsing while hand-written code handles complex logic

4. **Type Safety**: Macro-generated code ensures consistent type handling across all fields and messages

## Future Considerations

The `codegen/parser.rs` module in the macro crate contains template functions that demonstrate how more parsing logic could be moved to macro generation if needed. However, the current hybrid approach provides a good balance of code generation and manual implementation.